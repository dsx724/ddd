#!/bin/bash

set -e

DD_IF="if"
DD_OF="of"
DD_BS="bs"
DD_CNT="count"
DD_STS="status"
DD_SKIP="skip"
DD_SEEK="seek"

DDD_WRITE_BS_SHIFT=20 #1MiB
DDD_WRITE_BS=$((1 << $DDD_WRITE_BS_SHIFT))

declare -A ddd_params=(
	[$DD_BS]=512
)
ddd_cmd="dd"

ddd_checkPreReqs(){
	if ! which blockdev > /dev/null; then
		echo "$FUNCNAME: ddd requires blockdev" >&2
		return 1
	fi
}

ddd_requiredParams(){
	if [ -z "${ddd_params[$DD_IF]}" ]; then
		echo "$FUNCNAME: $DD_IF parameter missing" >&2
		return 1
	fi
	if [ -z "${ddd_params[$DD_OF]}" ]; then
		echo "$FUNCNAME: $DD_OF parameter missing" >&2
		return 1
	fi
}

ddd_convertMS2N(){
	#just a number, return number without leading 0s
	if [ -z "${1//[0-9]}" ]; then
		echo "${1##0*}"
		return
	fi

	local digit=$(echo "$1" | sed "s/[^0-9]*\$//")
	local suffix=$(echo "$1" | sed "s/^[0-9]*//")

	if [ "$1" != "$digit$suffix" ]; then
		echo "$FUNCNAME: I/O seek parameter is invalid" >&2
		return 1
	fi

	if [ -z "$digit" ]; then
		local digit=1
	fi

	if [ -z "$suffix" ]; then
		echo -n "$digit"
		return
	fi

	if [ "${#suffix}" -gt 1 ]; then
		echo "$FUNCNAME: I/O seek parameter suffix is unsupported" >&2
		return 1
	fi
	local base=1000
	case "${suffix,,}" in
		"k")
			local exponent=1
			;;
		"m")
			local exponent=2
			;;
		"g")
			local exponent=3
			;;
		"t")
			local exponent=4
			;;
		"p")
			local exponent=5
			;;
		"e")
			local exponent=6
			;;
		"z")
			local exponent=7
			;;
		"y")
			local exponent=8
			;;
		*)
			echo "$FUNCNAME: I/O seek parameter suffix is unsupported" >&2
			return 1
	esac
	echo -n "$((digit*(base**exponent)))"
}

ddd_convertB2BS(){
	local digit="$1"
	local base=1024
	local exponent=0
	while [ "$digit" -ge "$base" ]; do
		if [ "$((digit % base))" -eq 0 ]; then
			local digit=$((digit >> 10))
			local exponent=$((exponent+1))
		fi
	done
	if [ "$exponent" -eq 0 ]; then
		local base=1000
		while [ "$digit" -ge "$base" ]; do
			if [ "$((digit % base))" -eq 0 ]; then
				local digit=$((digit / $base))
				local exponent=$((exponent+1))
			fi
		done
	fi
	case "$exponent" in
		0)
			local suffix=
			;;
		1)
			local suffix=K
			;;
		2)
			local suffix=M
			;;
		3)
			local suffix=G
			;;
		4)
			local suffix=T
			;;
		5)
			local suffix=P
			;;
		6)
			local suffix=E
			;;
		7)
			local suffix=Z
			;;
		8)
			local suffix=Y
			;;
		*)
			echo "$FUNCNAME: suffix is not supported" >&2
			;;
	esac
	if [ "$base" -eq 1000 ]; then
		local suffix="${suffix}B"
	fi
	echo -n "$digit$suffix"
}

ddd_convertBS2B(){
	#empty bs is prefiltered by main
	#just a number, return number without leading 0s
	if [ -z "${1//[0-9]}" ]; then
		echo "${1##0*}"
		return
	fi

	local digit=$(echo "$1" | sed "s/[^0-9]*\$//")
	local suffix=$(echo "$1" | sed "s/^[0-9]*//")

	if [ "$1" != "$digit$suffix" ]; then
		echo "$FUNCNAME: $DD_BS parameter is invalid" >&2
		return 1
	fi

	if [ -z "$digit" ]; then
		local digit=1
	fi

	if [ -z "$suffix" ]; then
		echo -n "$digit"
		return
	fi

	if [ "${#suffix}" -gt 3 ]; then
		echo "$FUNCNAME: $DD_BS parameter suffix is unsupported" >&2
		return 1
	fi
	local base=1
	local exponent=1
	case "$suffix" in
		"c")
			:
			;;
		"w")
			local digit=$((digit<<1))
			;;
		"b")
			local digit=$((digit<<9))
			;;
		*)
			local base=1024
			if [ "${#suffix}" = 2 ]; then
				if [ "${suffix:1:1}" != "B" ]; then
					echo "$FUNCNAME: $DD_BS parameter suffix is unsupported" >&2
					return 1
				fi
				local base=1000
			elif [ "${#suffix}" = 3 ]; then
				if [ "${suffix:1:2}" != "iB" ]; then
					echo "$FUNCNAME: $DD_BS parameter suffix is unsupported" >&2
					return 1
				fi
			fi
			local suffix="${suffix:0:1}"
			case "${suffix,,}" in
				"k")
					local exponent=1
					;;
				"m")
					local exponent=2
					;;
				"g")
					local exponent=3
					;;
				"t")
					local exponent=4
					;;
				"p")
					local exponent=5
					;;
				"e")
					local exponent=6
					;;
				"z")
					local exponent=7
					;;
				"y")
					local exponent=8
					;;
				*)
					echo "$FUNCNAME: $DD_BS parameter suffix is unsupported" >&2
					return 1
			esac
			;;
	esac
	echo -n "$((digit*(base**exponent)))"
}

ddd_calculateWriteSize(){
	if [ -b "${ddd_params[$DD_IF]}" ]; then
		local input_size=$(blockdev --getsize64 "${ddd_params[$DD_IF]}")
	elif [ -f "${ddd_params[$DD_IF]}" ]; then
		local input_size=$(stat -c %s "${ddd_params[$DD_IF]}")
	else #TODO: add check for character devices
		echo "$FUNCNAME: $DD_IF parameter is not a block device or file" >&2
		return 1
	fi

	#if [ -b "${ddd_params[$DD_OF]}" ]; then
		local output_size=$(blockdev --getsize64 "${ddd_params[$DD_OF]}")
	#else #TODO add support for non block devices
	#	:
	#fi

	if [ "$output_size" -lt "$input_size" ]; then
		echo "$FUNCNAME: $DD_OF parameter is smaller than $DD_IF parameter" >&2
		return 1
	fi

	if [ -z "${ddd_params[$DD_CNT]}" ]; then
		local write_size=$input_size
	else
		#write size = bs * count
		local write_size=$((${ddd_params[$DD_BS]}*${ddd_params[$DD_CNT]}))
		if [ "$write_size" -gt "$input_size" ]; then
			echo "$FUNCNAME: $DD_IF parameter is smaller than $DD_BS * $DD_CNT" >&2
			local write_size=$input_size
		fi
	fi

	echo -n "$write_size"
}

ddd_write(){
	local ddd_write_blocks=0

	local write_size=$(ddd_calculateWriteSize)
	local write_blocks=$((write_size >> $DDD_WRITE_BS_SHIFT))
	local write_remainder=$((write_size % (1 << $DDD_WRITE_BS_SHIFT)))
	
	if [ "$write_blocks" -gt 0 ]; then
		for block_i in $(seq 0 $(($write_blocks-1))); do
			cmp -s  <(dd if="${ddd_params[$DD_IF]}" bs=$DDD_WRITE_BS skip=$block_i count=1 status=none) \
				<(dd if="${ddd_params[$DD_OF]}" bs=$DDD_WRITE_BS skip=$block_i count=1 status=none iflag=nocache) && local ret=$? || local ret=$?
			case "$ret" in
				0)
					:
					;;
				1)
					echo "$FUNCNAME: mismatch at block $block_i" >&2
					local ddd_write_blocks=$((ddd_write_blocks+1))
					ddd_writeBlock $block_i
					;;
				*)
					echo "$FUNCNAME: compare error on block $block_i with block size $(ddd_convertB2BS ${DDD_WRITE_BS})" >&2
					return 1
					;;
			esac
		done
	fi

	if [ "$write_remainder" -gt 0 ]; then
		local block_i=$write_blocks
		local byte_offset=$((block_i*$DDD_WRITE_BS))
		cmp -s -n "$write_remainder" \
			<(dd if="${ddd_params[$DD_IF]}" bs=$write_remainder skip=${byte_offset}B count=1 status=none) \
			<(dd if="${ddd_params[$DD_OF]}" bs=$write_remainder skip=${byte_offset}B count=1 status=none iflag=nocache) && local ret=$? || local ret=$?
		case "$ret" in
			0)
				:
				;;
			1)
				echo "$FUNCNAME: correcting mismatch at block $block_i"
				local ddd_write_blocks=$((ddd_write_blocks+1))
				ddd_writeBlock "${byte_offset}B" "$write_remainder"
				;;
			*)
				echo "$FUNCNAME: compare error on block $block_i with block size $(ddd_convertB2BS ${DDD_WRITE_BS})" >&2
				return 1
				;;
		esac
	fi

	echo "$FUNCNAME: $ddd_write_blocks blocks of $(ddd_convertB2BS ${DDD_WRITE_BS}) written"
}

ddd_writeBlock(){
	local write_bs="${2:-$DDD_WRITE_BS}"
	if ! dd if="${ddd_params[$DD_IF]}" of="${ddd_params[$DD_OF]}" bs="$write_bs" skip="$1" seek="$1" count=1 status=none oflag=sync; then
		echo "$FUNCNAME: failed at block $1" >&2
		return 1
	fi
	if ! cmp -s -n "$write_bs" <(dd if="${ddd_params[$DD_IF]}" bs="$write_bs" skip="$1" count=1 status=none) \
				   <(dd if="${ddd_params[$DD_OF]}" bs="$write_bs" skip="$1" count=1 status=none iflag=nocache); then
		echo "$FUNCNAME: unable to correct mismatch at block $1" >&2
		return 1
	fi
}

ddd_main(){

	ddd_checkPreReqs

	while [ ! -z "$1" ]; do
		local ddd_param="${1%%=*}"
		local ddd_param_value=${1#$ddd_param=}
		case "$ddd_param" in
			$DD_IF)
				if [ ! -e "$ddd_param_value" ]; then
					echo "$FUNCNAME: $ddd_param parameter value does not exist" >&2
					return 1
				fi
				if [ ! -r "$ddd_param_value" ]; then
					echo "$FUNCNAME: $ddd_param parameter value is not readable" >&2
					return 1
				fi
				ddd_params[$ddd_param]="$ddd_param_value"
				;;
			$DD_OF)
				if [ ! -e "$ddd_param_value" ]; then
					echo "$FUNCNAME: $ddd_param parameter value does not exist" >&2
					return 1
				fi
				if [ ! -b "$ddd_param_value" ]; then
					echo "$FUNCNAME: $ddd_param parameter is not a block device" >&2
					return 1
				fi
				if [ ! -w "$ddd_param_value" ]; then
					echo "$FUNCNAME: $ddd_param parameter value is not writable" >&2
					return 1
				fi
				ddd_params[$ddd_param]="$ddd_param_value"
				;;
			$DD_BS)
				ddd_params[$ddd_param]="$(ddd_convertBS2B "$ddd_param_value")"
				;;
			$DD_CNT)
				if [ ! -z "${ddr_param_value//[0-9]}" ]; then
					echo "$FUNCNAME: $ddd_param parameter is not a valid integer" >&2
					return 1
				fi
				ddd_params[$ddd_param]="${ddd_param_value##0*}"
				;;
			$DD_STS)
				case "$ddd_param_value" in
					"none")
						:
						;;
					"noxfer")
						:
						;;
					"progress")
						:
						;;
					*)
						echo "$FUNCNAME: $ddd_param parameter is not valid" >&2
						return 1
						;;
				esac
				ddd_params[$ddd_param]="$ddd_param_value"
				;;
			$DD_SKIP)
				if [ ! -z "$(echo "${ddd_param_value: -1}" | sed "s/[0-9B]//")" ]; then
					echo "$FUNCNAME: $ddd_param parameter must be block size multiple or an byte offset" >&2
					return 1
				fi
				ddd_params[$ddd_param]="$ddd_param_value"
				;;
			$DD_SEEK)
				if [ ! -z "$(echo "${ddd_param_value: -1}" | sed "s/[0-9B]//")" ]; then
					echo "$FUNCNAME: $ddd_param parameter must be block size multiple or an byte offset" >&2
					return 1
				fi
				ddd_params[$ddd_param]="$ddd_param_value"
				;;
			*)
				echo "$FUNCNAME: unrecognized parameter $ddd_param." >&2
				exit 1
				;;
		esac
		shift
	done

	ddd_requiredParams

	for ddd_param in "${!ddd_params[@]}"; do
		if [ -z "${ddd_params[$ddd_param]}" ]; then
			ddd_cmd+=" $ddd_param"
		else
			ddd_cmd+=" $ddd_param=${ddd_params[$ddd_param]}"
		fi
	done
	echo $ddd_cmd

	ddd_write
}

ddd_main "$@"
